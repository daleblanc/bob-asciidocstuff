= Bash Commands Cheat Sheet
:experimental: true
:product-name: Bash Commands Cheat Sheet

== Bash Script Header

Typically a bash script has a ![shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)) declaration on the first line to specify the interpreter that executes the script's commands.

The `env` command tells the system to search for the specified interpreter through the `$PATH` variable. Usually the interpreter is located in the `/usr/bin/env` directory of a Unix-based system.

```
#!/usr/bin/env bash
```

In this case, the shebang clause tells the system to use `bash`. Another interpreter such as `sh` could be defined as well.

== Variables & Strings

=== Variable declaration

You declare a variable in a bash script like so `VARIABLE_NAME=<value>` **WHERE**  `<value>` is the value assigned to the variable. Then, to reference the variable, put the `$` symbol before the variable name being referenced, like so: `$VARIABLE_NAME`.

*Example:*

```
#!/usr/bin/env bash
MSG="Hello World"
echo "$MSG " # Hello World
```

**BE CAREFUL** to make sure there is no space on either side of the `=` symbol when declaring a variable. The following will **not** work: `MYVARIABLE = foo`.

=== String manipulation using parameter expansion

Parameter expansion a technique to get the value from the referenced entity such as a variable in a Linux script or an environment variable according to a piece of processing logic. A variable is processed by enclosing the variable name within the `${  }` characters. The processing logic is defined by characters that follow the variable name. For example to the variable named `MSG`, the statement `${MSG^^}` turns all lowercase characters in the variable `MSG` to uppercase, like so:

```
MSG="aBcDeFg"
echo ${MSG^^}

#returns ABCDEFG
```

And the statement `${MSG,,}` turns all uppercase characters in the variable `MSG` to lowercase, like so:

```
MSG="aBcDeFg"
echo ${MSG,,}

#returns abcdef
```

The following examples demonstrate various ways use parameter expansion on Linux variables.

*Word Replacement*

```
MSG="Say hi to Chris and Sidney"
echo ${MSG//Chris/Billy}

#returns Say hi to Billy and Sidney
```

*Character Replacement Using Regular Expressions*

Replace all alphabetic characters with the character `X` but leave numeral alone

```
MSG="I need 10"
echo ${MSG//[a-zA-Z]/X}

#returns X XXXX 10
```

---

Replace all numeric characters with the character `Z` but leave alphabetic characters alone

```
MSG="I need 10"
echo ${MSG//[0-9]/Z}

#returns I need ZZ
```

*Extracting Substrings*

Use the `:` symbol to get the substring of all the characters after the starting at position 4

```
MSG="The Rolling Stones"
echo ${MSG:4}

#returns Rolling Stones
```

---

Use the `:` symbol to get the substring that has 7 characters starting at position 4

```
MSG="The Rolling Stones"
echo ${MSG:4:7}

#returns Rolling
```

---

Use the `#` symbol to get the substring after the characters `The` starting from the left side of the string

```
MSG="The Rolling Stones"
echo ${MSG#The} 

#returns Rolling Stones

```

---

Use the `%` symbol to get the substring before the characters `Rolling Stones` starting the right side of the string

```
MSG="The Rolling Stones"
echo ${MSG%Rolling Stones} 

#returns The

```

*Case Conversion*

Use the `^` symbol to convert the first character in a string to uppercase.

```
 MSG="aBcDeFg"
 echo ${MSG^}

 #returns ABcDeFg

```

---

Use the `^^` symbols to convert the all lowercase characters in a string to uppercase.

```
 MSG="aBcDeFg"
 echo ${MSG^^}

 #returns ABCDEFG

```

---

Use the `,` symbol to convert the first character in a string to lowercase.

```
 MSG="TuVwXyZ"
 echo ${MSG,}

 #returns tuVwXyZ

```

---

Use the `,,` symbols to convert all characters in a string to lowercase.

```
 MSG="TuVwXyZ"
 echo ${MSG,}

 #returns tuvwxyz

```

== Collections

The following sections describe how to group data as a collection in a bash script. Bash supports two types of collection. One type is an `array`. The other type is a `map`.

An `array` is a collection in which elements of the collection are accessed according to a number.

A `map` is a collection in which elements of the collection a key value.

=== Arrays

*Creating an array*

The following creates an array with three elements and assigns the array to the variable named `my_array`.

```
my_array=('Alex' 'Ada' 'Alexandra')
```

*Adding an element to an array*

The following uses the `+=` operator to add an element with the value `Soto` to the array named `my_array`.

```
my_array+=('Soto')
```

*Removing  an element to an array*

The following uses the `unset` keyword to remove the fourth element from the array named `my_array` at index `3`.

```
unset my_array[3]
```

*Viewing data in an array*

The following uses an index number to view the data in the first element of the array named `my_array`.

```
echo ${my_array[0]}
```

The following uses an index number to view the data in the third element of the array named `my_array`.

```
echo ${my_array[2]}
```

The following uses the `@` symbol to view all elements in the array named `my_array`.

```
echo ${my_array[@]}
```

*Getting the number of elements in an array*

The following uses the `#` and `@` symbols to get a count of the number of elements in the array named `my_array`.

```
echo ${#names[@]} # 3
```

*Copy, paste and run in your terminal:*

Copy and paste the following code into your terminal window to create and execute a Bash script with the filename `arrays-01.sh`.

The Bash script demonstrates the array commands described above.

```
cat << 'EOF' > arrays-01.sh
#!/usr/bin/env bash

names=('Alex' 'Ada' 'Alexandra')
names+=('Soto') # Appends element, Soto
unset names[3] # Removes element at index 3, (Soto)

echo ${names[0]} # Alex
echo ${names[1]} # Ada
echo ${names[2]} # Alexandra

# @ indicates all elements in the array
echo ${names[@]} # Alex Ada Alexandra

# Count of names
echo ${#names[@]} # 3
EOF
sh arrays-01.sh
```

=== Maps

```
declare -A score
score[alex]="1"
score[edson]="2"
score[sebi]="3"
score[chris]="4"
echo ${!score[@]} # alex edson sebi chris
unset score[chris] # Delete chris entry
echo ${score[@]} # show all the values
echo ${!score[@]} # show all keys
echo ${score[edson]} # show the value of edson: 2
echo ${#score[@]} # show the number of elements in the map: 3
EOF
```

*Copy, paste and run in your terminal:*

```
cat << 'EOF' > maps-01.sh
#!/usr/bin/env bash

declare -A score
score[alex]="1"
score[edson]="2"
score[sebi]="3"
score[chris]="4"
echo ${!score[@]} # alex edson sebi chris
unset score[chris] # Delete chris entry
echo ${score[@]} # show all the values
echo ${!score[@]} # show all keys
echo ${score[edson]} # show the value of edson: 2
echo ${#score[@]} # show the number of elements in the map: 3
EOF
sh maps-01.sh
```

== Functions

A basic function

```
helloworld() {
  echo "Number of arguments $#" # 2
  echo "Hello World $1 from $2" # Hello World Alex from Bash
  }

helloworld "Alex" "Bash"
```

*Copy, paste and run in your terminal:*

```
cat << 'EOF' > function-01.sh
#!/usr/bin/env bash

helloworld() {
  echo "Number of arguments $#" # 2
  echo "Hello World $1 from $2" # Hello World Alex from Bash
  }

helloworld "Alex" "Bash"
EOF


sh function-01.sh
```

---

A function that sets a value to a global variable

```
goodmorning () {
  # set a value for the global variable named myresult
  myresult='Good Morning'
 }
```

*Copy, paste and run in your terminal:*

```
cat << 'EOF' > function-02.sh
#!/usr/bin/env bash

goodmorning () {
  # set a value for the global variable named myresult
  myresult='Good Morning'
 }

goodmorning
echo $myresult
EOF

sh function-02.sh
```

---

A function that returns a numeric code on exit

Exiting with a value of `0` means success. Any higher number means a failure condition by convention

```
myfunc()
{
    echo "this is a message from myfunc()"
    exit 0
}
```

*Copy, paste and run in your terminal:*

```
cat << 'EOF' > function-03.sh
#!/usr/bin/env bash

myfunc()
{
echo "this is a message from myfunc()"
exit 0
}

# run the custom function named myfunc
myfunc
EOF

sh function-03.sh && echo "$?"
```

A function that returns a numeric code on using return

== Conditional Statements

=== Numeric statements

=== String statements

=== File statements

== Loops

=== Range
```
for i in {1..5}; do
  echo "Hello World $i"
done
```

*Copy, paste and run in your terminal:*

```
cat << 'EOF' > basic-range-01.sh
#!/usr/bin/env bash

for i in {1..5}; do
  echo "Hello World $i"
done

EOF

sh basic-range-01.sh
```

=== Collections

Print all elements from a plain array:

```
for i in "${names[@]}"; do
  echo "Hello $i"
done
```

*Copy, paste and run in your terminal:*

```
cat << 'EOF' > range-names-01.sh
#!/usr/bin/env bash

names=('Alex' 'Ada' 'Alexandra', 'Soto')

for i in "${names[@]}"; do
  echo "Hello $i"
done

EOF

sh range-names-01.sh
```

---

Print keys of all elements from a key/value array:

```
for key in "${!score[@]}"; do
  echo $key
done
```

*Copy, paste and run in your terminal:*

```
cat << 'EOF' > range-keys-01.sh
#!/usr/bin/env bash

declare -A score

score[alex]="1"
score[edson]="2"
score[sebi]="3"
score[chris]="4"

for key in "${!score[@]}"; do
  echo $key
done

EOF
sh range-keys-01.sh
```

---

Print values of all elements from a key/value array:

```
for val in "${score[@]}"; do
  echo $val
done
```

*Copy, paste and run in your terminal:*

```
cat << 'EOF' > value-keys-01.sh
#!/usr/bin/env bash

declare -A score

score[alex]="1"
score[edson]="2"
score[sebi]="3"
score[chris]="4"

for val in "${score[@]}"; do
  echo $val
done

EOF
sh value-keys-01.sh
```

=== Files and Directories

*Get all files in a directory sub-directories*

The following script gets all files in the directory `/tmp` that have the extension `.log`:

```
for i in /tmp/*.log; do
  echo $i
done
```

*Copy, paste and run in your terminal:*

```
cat << 'EOF' > files-01.sh
#!/usr/bin/env bash

echo All log files in the /tmp directory

for i in /tmp/*.log; do
  echo $i
done
EOF
sh files-01.sh
```

---

*Get all sub-directories*

The following script gets all subdirectories in the directory `/var`

```
for i in /var/*; do
  echo $(basename "$i")
done
```

*Copy, paste and run in your terminal:*

```
cat << 'EOF' > files-02.sh
#!/usr/bin/env bash

echo All subdirectories in /var

for i in /var/*; do
  echo $(basename "$i")
done
EOF

sh files-02.sh
```

=== While loop
```
x=1;
while [ $x -le 5 ]; do
  echo "Hello World"
  ((x=x+1))
done
```

*Copy, paste and run in your terminal:*

```
cat << 'EOF' > while-loop-01.sh
#!/usr/bin/env bash

x=1;
while [ $x -le 5 ]; do
  echo "Hello World"
  ((x=x+1))
done
EOF

sh while-loop-01.sh
```

*Copy, paste and run in your terminal:*
== Executing Commands

== Useful Snippets